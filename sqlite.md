# Wishlist for SQLite

## CREATE OR REPLACE VIEW

Dropping existing views to handle updating an old schema and creating
a new database is useless boilerplate. Should not have the restriction
found in PostgreSQL (there you can only add columns to the view, not
replace it entirely).

## `agg(... ORDER BY ...)`

Suppose you generate a (mathematical) set like:

```sql
  ...
  JSON_GROUP_ARRAY(DISTINCT value)
  ...
```

Two such sets cannot be compared for equality based on the JSON-text
generated by the aggregate function, but if `JSON_GROUP_ARRAY` would
promise to reflect input order in the output, and input order could
be controlled by (as in PostgreSQL):

```sql
  ...
  JSON_GROUP_ARRAY(DISTINCT value ORDER BY value)
  ...
```

## Constraint propagation in recursive CTE VIEWs

As of 2021-05-01, SQLite fails to propagate equality constraints when
selecting from recursive `VIEW`s even in straight-forward cases like:

```sql
CREATE VIEW example AS
WITH RECURSIVE 
step AS (
  SELECT root, ...
  UNION
  SELECT step.root, ... FROM step ...
)
SELECT root, ... FROM step ...
;

SELECT ... FROM example WHERE root = :wanted
```

## Extension Archive

It is hard to find extensions that already exist. It is hard to make
them work for your environment.

## Override function from running statement

SQLite has this logic:

```c
  /* Check if an existing function is being overridden or deleted. If so,
  ** and there are active VMs, then return SQLITE_BUSY. If a function
  ** is being overridden/deleted but there are no active VMs, allow the
  ** operation to continue but invalidate all precompiled statements.
  */
  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 0);
  if( p && (p->funcFlags & SQLITE_FUNC_ENCMASK)==(u32)enc && p->nArg==nArg ){
    if( db->nVdbeActive ){
      sqlite3ErrorWithMsg(db, SQLITE_BUSY,
        "unable to delete/modify user-function due to active statements");
      assert( !db->mallocFailed );
      return SQLITE_BUSY;
    }else{
      sqlite3ExpirePreparedStatements(db, 0);
    }
  }
```

That means you can create new functions with SQL statements, but you
cannot replace or remove them. That frustrates extension authors who
miss `CREATE FUNCTION` support in SQLite.

## Extension loader extension

If you do not want to allow promiscuously loading extensions, but
also do not want to configure extension loading in multiple places,
it should be possible to make an extension that loads other
extensions (where the extension takes care of filtering permissable
extensions, like those located in a special directory). Something
like:

```sql
CREATE VIRTUAL TABLE ext USING extension_loader((
  statement from 'https://raw.githubusercontent.com/0x09/sqlite-statement-vtab/master/statement_vtab.c'
  ,
  uuid from 'https://raw.githubusercontent.com/sqlite/sqlite/master/ext/misc/uuid.c'
));
```

You could then load specifically the `extension_loader` extension,
and let the database schema ensure the presence of dependencies.
Allowing some reference to the extension source can then also make
the schema self-documenting.

## Poor man's MATERIALIZED VIEWs

Something along these lines should be possible?

```sql
CREATE VIRTUAL TABLE mv AS materialized_views(

  view_deriv_after_vertex WITH (
    CREATE INDEX idx_vdav_xxx ON view_deriv_after_vertex();
    CREATE INDEX idx_vdav_xxx ON view_deriv_after_vertex();
  )

);

UPDATE mv SET refresh = TRUE;
UPDATE mv SET disable = TRUE;
```

## Automatic tracing

```sql
CREATE VIRTUAL TABLE audit_trace USING audit_trace(
  open           = '',
  backup         = 1,
  table          = 'trace',
  sql_normalized = 1,
  sql_expanded   = 1,
  trace_stmt     = 1,
  trace_profile  = 1,
  trace_row      = 1,
  trace_close    = 1,
);
```

This would register a `sqlite3_trace_v2` callback and write data into
the specified database table, filtered according to the trace settings.
Optionally the original database would be cloned into the new one. At
user option, `sqlite3_expanded_sql` and `sqlite3_normalized_sql` SQL
text can be included in the table.

There are some open questions when re-loading the database after the
virtual table has been created, should that refresh the backup, keep
the tracing data, how to trigger continued tracing...

The main goal is to provide a ideally self-contained database that
can be used to inspect performance or other problems, inclunding
making it easy to submit something to the SQLite developers, with
possibly extra tooling to scrub the database beforehand, like simple
obfuscation of schema object names.

`trace_profile` should probably also record the counter values from
`sqlite3_stmt_status`.

## udf extension


## GENERATED ALWAYS is not a type

This is somewhat unfortunate:

```
sqlite> create table t(id int, x int generated always as (true));
Run Time: real 0.000 user 0.000345 sys 0.000103
sqlite> create view v as select * from t;
Run Time: real 0.000 user 0.000262 sys 0.000096
sqlite> select * from pragma_table_info('v');
cid  name  type                  notnull  dflt_value  pk
---  ----  --------------------  -------  ----------  --
0    id    int                   0                    0 
1    x     int generated always  0                    0 
Run Time: real 0.000 user 0.000331 sys 0.000121
```

Especially considering:

```
sqlite> create table t2 as select * from t;
Run Time: real 0.000 user 0.000380 sys 0.000126
sqlite> select * from pragma_table_info('t2');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    id    INT   0                    0 
1    x     INT   0                    0 
Run Time: real 0.001 user 0.000212 sys 0.000070
sqlite> create table t3 as select * from v;
Run Time: real 0.000 user 0.000290 sys 0.000120
sqlite> select * from pragma_table_info('t3');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    id    INT   0                    0 
1    x     INT   0                    0 
Run Time: real 0.001 user 0.000000 sys 0.000385
```

## Method to query schema object dependencies

There should be a virtual table that details dependencies between
schema objects (like tables and views). There is `TABLES_USED` via
<https://www.sqlite.org/bytecodevtab.html> but it does not list
view->view dependencies, and does not list the columns referenced
only the tables. It is also not clear to me if there is a way to
use it when the database driver in some programming environment
has not been compiled with `-DSQLITE_ENABLE_BYTECODE_VTAB`.

This is needed e.g. when you want to materialize VIEWs in their
proper topological order. And that is something you might want to
do to debug performance issues.

Third-party extensions cannot really provide this functionality
because this requires parsing the SQLs involved, which in turn
only SQLite itself knows how to do.

It is possible to get this information through `ALTER TABLE`
rename operations (turning VIEWs temporarily into tables), but
that is rather ugly, and `ALTER TABLE` is fairly buggy as of
mid-2021.

Update: 3.36.0 probably improves ALTER TABLE RENAME TO, but
ALTER TABLE RENAME COLUMN is too too broken to use for this.

## xBestIndex and constant values

When a VIRTUAL TABLE is used with one of the arguments bound
to a constant

```
SELECT * FROM vtab('constant')
```

it would be nice if xBestIndex gets to know that to provide
better plan cost and row count estimates to the optimizer.

## VIRTUAL TABLE documentation problems

* The `xBestIndex` method's primary function is to help SQLite
pass input values as arguments to `xFilter`. That could be made
much more obvious.

* xRowid is seemingly often implemented by vtable extensions as a
simple row counter on the cursor, and the values might end up in
xUpdate for the less common case of writable virtual tables. But
the documentation also hints at cases where there may be multiple
open cursors, and of course user code might read ROWIDs out of
virtual tables. It seems likely that simple counters would then
easily break expectations. The support for `WITHOUT ROWID` tables
hints at that, but short of storing results from previous queries
virtual table implementations might have a hard time to generate
ROWIDs or corresponding PRIMARY KEY constraints as needed for
WITHOUT ROWID tables. The documentation could do a better job in
managing expectations here.

## Doubt: Shadow tables and triggers

Can untrusted code create/drop/alter trigger programs associated
with shadow tables of virtual tables? If they can, would triggers
run when the virtual table makes changes to the shadow tables? Do
the programs then run as untrusted code or as trusted code? In
other words, how does SQLite protect shadow tables from untrusted
writes through trigger programs? This is probably just missing in
the documentation, but could also be a security problem.

Update:

```
 % sqlite
-- Loading resources from /home/bjoern/.sqliterc
SQLite version 3.36.0 2021-06-11 13:18:56
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> .dbconfig defensive on
          defensive on
sqlite> CREATE VIRTUAL TABLE email USING fts3(sender, title, body);
sqlite> INSERT INTO email(sender) VALUES('abc');
sqlite> UPDATE email_content SET c0sender = 'XXX';
(1) table email_content may not be modified in "UPDATE email_content SET c0sender = 'XXX';"
Error: table email_content may not be modified
```

```
sqlite> CREATE TRIGGER t AFTER INSERT ON email_content BEGIN
   ...>   SELECT SQLITE_LOG(0, 'trigger');
   ...>   UPDATE email_content SET c0sender = 'XXX';
   ...>   END;
sqlite> INSERT INTO email(sender) VALUES('123');
(17) statement aborts at 16: [DELETE FROM 'main'.'email_segdir' WHERE level = ?] database schema has changed
(17) statement aborts at 16: [INSERT INTO 'main'.'email_content' VALUES(?,(?),(?),(?))] database schema has changed
(0) trigger
(17) statement aborts at 24: [SELECT (SELECT max(idx) FROM 'main'.'email_segdir' WHERE level = ?) + 1] database schema has changed
(17) statement aborts at 22: [SELECT coalesce((SELECT max(blockid) FROM 'main'.'email_segments') + 1, 1)] database schema has changed
(17) statement aborts at 25: [REPLACE INTO 'main'.'email_segdir' VALUES(?,?,?,?,?,?)] database schema has changed
(17) statement aborts at 39: [SELECT level, idx, end_block FROM 'main'.'email_segdir' WHERE level BETWEEN ? AND ? ORDER BY level DESC, idx ASC] database schema has changed
sqlite> INSERT INTO email(sender) VALUES('123');
(0) trigger
```

```
sqlite> .dump email_content
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE IF NOT EXISTS 'email_content'(docid INTEGER PRIMARY KEY, 'c0sender', 'c1title', 'c2body');
INSERT INTO email_content VALUES(1,'XXX',NULL,NULL);
INSERT INTO email_content VALUES(2,'XXX',NULL,NULL);
INSERT INTO email_content VALUES(3,'XXX',NULL,NULL);
COMMIT;
sqlite> 
```

So the shadow table write protection is ineffective when untrusted code
can create triggers.

## PRAGMA_TABLE_INFO vs CREATE TABLE AS SELECT type handling

```
sqlite> create view v as select CAST(each.value AS INT) from json_each('[1,2,3]') each;
Run Time: real 0.008 user 0.001449 sys 0.000000
sqlite> create table t as select * from v;
Run Time: real 0.008 user 0.000000 sys 0.001647
sqlite> select * from pragma_table_info('v');
cid  name                     type  notnull  dflt_value  pk
---  -----------------------  ----  -------  ----------  --
0    CAST(each.value AS INT)        0                    0 
Run Time: real 0.001 user 0.000000 sys 0.000408
sqlite> select * from pragma_table_info('t');
cid  name                     type  notnull  dflt_value  pk
---  -----------------------  ----  -------  ----------  --
0    CAST(each.value AS INT)  INT   0                    0 
Run Time: real 0.000 user 0.000250 sys 0.000134
```

## Odd table scans due to declared types:

The only difference between these query plans is that table `vur` has
no declared type in the first plan...

```
QUERY PLAN
|--CO-ROUTINE step
|  |--SETUP
|  |  `--SCAN s
|  `--RECURSIVE STEP
|     `--COMPOUND QUERY
|        |--LEFT-MOST SUBQUERY
|        |  |--SCAN step
|        |  |--SEARCH input USING INTEGER PRIMARY KEY (rowid=?)
|        |  |--SCAN vur
|        |  `--SEARCH t USING AUTOMATIC COVERING INDEX (goal_dc=? AND src_state=? AND via=?)
|        `--UNION ALL
|           |--SCAN step
|           `--SEARCH n USING AUTOMATIC COVERING INDEX (goal_dc=? AND state=?)
```

... but in the second plan the declared type of all columns is INT:


```
QUERY PLAN
|--CO-ROUTINE step
|  |--SETUP
|  |  `--SCAN s
|  `--RECURSIVE STEP
|     `--COMPOUND QUERY
|        |--LEFT-MOST SUBQUERY
|        |  |--SCAN step
|        |  |--SEARCH input USING INTEGER PRIMARY KEY (rowid=?)
|        |  |--SEARCH t USING AUTOMATIC COVERING INDEX (goal_dc=? AND src_state=?)
|        |  `--SEARCH vur USING AUTOMATIC COVERING INDEX (representative=?)
|        `--UNION ALL
|           |--SCAN step
|           `--SEARCH n USING AUTOMATIC COVERING INDEX (goal_dc=? AND state=?)
`--SCAN step
```

## pragma_table_info ignores schema

```
 bjoern@hpx360  ~  sqlite                                                                                     1 ↵  30.27  00:31:30
-- Loading resources from /home/bjoern/.sqliterc
SQLite version 3.36.0 2021-06-11 13:18:56
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite> attach database ':memory:' as m;
Run Time: real 0.001 user 0.000083 sys 0.000332
sqlite> create table main.t(x int);
Run Time: real 0.001 user 0.000000 sys 0.000431
sqlite> create table m.t(x text);
Run Time: real 0.001 user 0.000000 sys 0.000364
sqlite> pragma main.table_info('t');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    x     int   0                    0 
Run Time: real 0.000 user 0.000170 sys 0.000000
sqlite> pragma m.table_info('t');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    x     text  0                    0 
Run Time: real 0.000 user 0.000171 sys 0.000000
sqlite> select * from main.pragma_table_info('t');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    x     int   0                    0 
Run Time: real 0.000 user 0.000361 sys 0.000000
sqlite> select * from m.pragma_table_info('t');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    x     int   0                    0 
Run Time: real 0.000 user 0.000242 sys 0.000000
sqlite> 
```

>  PRAGMAs that return results and that have no side-effects can be accessed from ordinary SELECT statements as table-valued functions. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character "pragma_" prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function. 

-- https://www.sqlite.org/pragma.html
