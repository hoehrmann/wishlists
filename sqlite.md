# Wishlist for SQLite

## CREATE OR REPLACE VIEW

Dropping existing views to handle updating an old schema and creating
a new database is useless boilerplate. Should not have the restriction
found in PostgreSQL (there you can only add columns to the view, not
replace it entirely).

## `agg(... ORDER BY ...)`

Suppose you generate a (mathematical) set like:

```sql
  ...
  JSON_GROUP_ARRAY(DISTINCT value)
  ...
```

Two such sets cannot be compared for equality based on the JSON-text
generated by the aggregate function, but if `JSON_GROUP_ARRAY` would
promise to reflect input order in the output, and input order could
be controlled by (as in PostgreSQL):

```sql
  ...
  JSON_GROUP_ARRAY(DISTINCT value ORDER BY value)
  ...
```

## Constraint propagation in recursive CTE VIEWs

As of 2021-05-01, SQLite fails to propagate equality constraints when
selecting from recursive `VIEW`s even in straight-forward cases like:

```sql
CREATE VIEW example AS
WITH RECURSIVE 
step AS (
  SELECT root, ...
  UNION
  SELECT step.root, ... FROM step ...
)
SELECT root, ... FROM step ...
;

SELECT ... FROM example WHERE root = :wanted
```

## Extension Archive

It is hard to find extensions that already exist. It is hard to make
them work for your environment.

## Override function from running statement

SQLite has this logic:

```c
  /* Check if an existing function is being overridden or deleted. If so,
  ** and there are active VMs, then return SQLITE_BUSY. If a function
  ** is being overridden/deleted but there are no active VMs, allow the
  ** operation to continue but invalidate all precompiled statements.
  */
  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 0);
  if( p && (p->funcFlags & SQLITE_FUNC_ENCMASK)==(u32)enc && p->nArg==nArg ){
    if( db->nVdbeActive ){
      sqlite3ErrorWithMsg(db, SQLITE_BUSY,
        "unable to delete/modify user-function due to active statements");
      assert( !db->mallocFailed );
      return SQLITE_BUSY;
    }else{
      sqlite3ExpirePreparedStatements(db, 0);
    }
  }
```

That means you can create new functions with SQL statements, but you
cannot replace or remove them. That frustrates extension authors who
miss `CREATE FUNCTION` support in SQLite.

## Extension loader extension

If you do not want to allow promiscuously loading extensions, but
also do not want to configure extension loading in multiple places,
it should be possible to make an extension that loads other
extensions (where the extension takes care of filtering permissable
extensions, like those located in a special directory). Something
like:

```sql
CREATE VIRTUAL TABLE ext USING extension_loader((
  statement from 'https://raw.githubusercontent.com/0x09/sqlite-statement-vtab/master/statement_vtab.c'
  ,
  uuid from 'https://raw.githubusercontent.com/sqlite/sqlite/master/ext/misc/uuid.c'
));
```

You could then load specifically the `extension_loader` extension,
and let the database schema ensure the presence of dependencies.
Allowing some reference to the extension source can then also make
the schema self-documenting.

## Poor man's MATERIALIZED VIEWs

Something along these lines should be possible?

```sql
CREATE VIRTUAL TABLE mv AS materialized_views(

  view_deriv_after_vertex WITH (
    CREATE INDEX idx_vdav_xxx ON view_deriv_after_vertex();
    CREATE INDEX idx_vdav_xxx ON view_deriv_after_vertex();
  )

);

UPDATE mv SET refresh = TRUE;
UPDATE mv SET disable = TRUE;
```

## Automatic tracing

```sql
CREATE VIRTUAL TABLE audit_trace USING audit_trace(
  open           = '',
  backup         = 1,
  table          = 'trace',
  sql_normalized = 1,
  sql_expanded   = 1,
  trace_stmt     = 1,
  trace_profile  = 1,
  trace_row      = 1,
  trace_close    = 1,
);
```

This would register a `sqlite3_trace_v2` callback and write data into
the specified database table, filtered according to the trace settings.
Optionally the original database would be cloned into the new one. At
user option, `sqlite3_expanded_sql` and `sqlite3_normalized_sql` SQL
text can be included in the table.

There are some open questions when re-loading the database after the
virtual table has been created, should that refresh the backup, keep
the tracing data, how to trigger continued tracing...

The main goal is to provide a ideally self-contained database that
can be used to inspect performance or other problems, inclunding
making it easy to submit something to the SQLite developers, with
possibly extra tooling to scrub the database beforehand, like simple
obfuscation of schema object names.

`trace_profile` should probably also record the counter values from
`sqlite3_stmt_status`.

## udf extension


## GENERATED ALWAYS is not a type

This is somewhat unfortunate:

```
sqlite> create table t(id int, x int generated always as (true));
Run Time: real 0.000 user 0.000345 sys 0.000103
sqlite> create view v as select * from t;
Run Time: real 0.000 user 0.000262 sys 0.000096
sqlite> select * from pragma_table_info('v');
cid  name  type                  notnull  dflt_value  pk
---  ----  --------------------  -------  ----------  --
0    id    int                   0                    0 
1    x     int generated always  0                    0 
Run Time: real 0.000 user 0.000331 sys 0.000121
```

Especially considering:

```
sqlite> create table t2 as select * from t;
Run Time: real 0.000 user 0.000380 sys 0.000126
sqlite> select * from pragma_table_info('t2');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    id    INT   0                    0 
1    x     INT   0                    0 
Run Time: real 0.001 user 0.000212 sys 0.000070
sqlite> create table t3 as select * from v;
Run Time: real 0.000 user 0.000290 sys 0.000120
sqlite> select * from pragma_table_info('t3');
cid  name  type  notnull  dflt_value  pk
---  ----  ----  -------  ----------  --
0    id    INT   0                    0 
1    x     INT   0                    0 
Run Time: real 0.001 user 0.000000 sys 0.000385
```
