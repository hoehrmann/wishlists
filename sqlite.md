# Wishlist for SQLite

## CREATE OR REPLACE VIEW

Dropping existing views to handle updating an old schema and creating
a new database is useless boilerplate. Should not have the restriction
found in PostgreSQL (there you can only add columns to the view, not
replace it entirely).

## `agg(... ORDER BY ...)`

Suppose you generate a (mathematical) set like:

```sql
  ...
  JSON_GROUP_ARRAY(DISTINCT value)
  ...
```

Two such sets cannot be compared for equality based on the JSON-text
generated by the aggregate function, but if `JSON_GROUP_ARRAY` would
promise to reflect input order in the output, and input order could
be controlled by (as in PostgreSQL):

```sql
  ...
  JSON_GROUP_ARRAY(DISTINCT value ORDER BY value)
  ...
```

## Constraint propagation in recursive CTE VIEWs

As of 2021-05-01, SQLite fails to propagate equality constraints when
selecting from recursive `VIEW`s even in straight-forward cases like:

```sql
CREATE VIEW example AS
WITH RECURSIVE 
step AS (
  SELECT root, ...
  UNION
  SELECT step.root, ... FROM step ...
)
SELECT root, ... FROM step ...
;

SELECT ... FROM example WHERE root = :wanted
```

## Extension Archive

It is hard to find extensions that already exist. It is hard to make
them work for your environment.

## Extension loader extension

If you do not want to allow promiscuously loading extensions, but
also do not want to configure extension loading in multiple places,
it should be possible to make an extension that loads other
extensions (where the extension takes care of filtering permissable
extensions, like those located in a special directory). Something
like:

```sql
CREATE VIRTUAL TABLE ext USING extension_loader((
  statement from 'https://raw.githubusercontent.com/0x09/sqlite-statement-vtab/master/statement_vtab.c'
  ,
  uuid from 'https://raw.githubusercontent.com/sqlite/sqlite/master/ext/misc/uuid.c'
));
```

You could then load specifically the `extension_loader` extension,
and let the database schema ensure the presence of dependencies.
Allowing some reference to the extension source can then also make
the schema self-documenting.

## Poor man's MATERIALIZED VIEWs

Something along these lines should be possible?

```sql
CREATE VIRTUAL TABLE mv AS materialized_views(

  view_deriv_after_vertex WITH (
    CREATE INDEX idx_vdav_xxx ON view_deriv_after_vertex();
    CREATE INDEX idx_vdav_xxx ON view_deriv_after_vertex();
  )

);

UPDATE mv SET refresh = TRUE;
UPDATE mv SET disable = TRUE;
```

## Automatic tracing

```sql
CREATE VIRTUAL TABLE audit_trace USING audit_trace(
  open           = '',
  backup         = 1,
  table          = 'trace',
  sql_normalized = 1,
  sql_expanded   = 1,
  trace_stmt     = 1,
  trace_profile  = 1,
  trace_row      = 1,
  trace_close    = 1,
);
```

This would register a `sqlite3_trace_v2` callback and write data into
the specified database table, filtered according to the trace settings.
Optionally the original database would be cloned into the new one. At
user option, `sqlite3_expanded_sql` and `sqlite3_normalized_sql` SQL
text can be included in the table.

There are some open questions when re-loading the database after the
virtual table has been created, should that refresh the backup, keep
the tracing data, how to trigger continued tracing...

The main goal is to provide a ideally self-contained database that
can be used to inspect performance or other problems, inclunding
making it easy to submit something to the SQLite developers, with
possibly extra tooling to scrub the database beforehand, like simple
obfuscation of schema object names.

## udf extension
